## 原始值与引用值

es 变量可以以包含两种不同类型的数据：原始值和引用值。  
原始值：简单类型的数据。栈内存存储的是实际值，可以直接操作。  
引用值：多个值构成的对象。栈内存存储的是该对象的引用。实际上操作的是对该对象的引用（reference）而非实际的对象本身。

- ### 动态属性
  原始值：不能添加动态属性
  引用值：可以添加、修改、删除动态属性和方法

* ### 复制值
  原始值：复制后的两个变量可以独立使用，互不干扰。
  引用值：复制的是栈内存的引用地址，他们指向同一个堆内存中的对象。因此一个对象上面的变化会在另一个对象上反映出来
* ### 传递参数

  所有函数的参数都是按值传递的，传递参数时，值会被复制到一个局部变量。

  ```js
  <!-- 原始值 -->
  function addTen(num) {
    num += 10
    return num
  }
  let count = 20
  let res = addTen(count)
  console.log(count) // 20
  console.log(res) // 30

  <!-- 引用值 -->
  function setName(obj) { // 相当于 let obj = person
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
  }
  let person = new Object();
  setName(person);
  console.log(person.name); // "Nicholas"
  ```

  当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。

* ### 确定类型

  typeof: 适合用来判断一个变量是否为原始类型。
  instanceof：instanceof 适合用来判断对象变量

  ```js
  object instanceof constructor
  object: 某个实例对象
  constructor: 某个构造函数
  描述：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。
  ```

  | typeof&nbsp; &nbsp;&nbsp;                              | instanceof                                              | Object.prototype.toString.call        |
  | :----------------------------------------------------- | :------------------------------------------------------ | :------------------------------------ |
  | 检测原始值，返回 type。检测 null 和对象时，返回 object | 可以判断对象，返回 Boolean 值。检测原始值时，返回 false | 对象和原始类型，返回的是[object Type] |

* ### 执行上下文与作用域
* 执行上下文  
  每个上下文都有一个关联的变量对象（variable object），
  而这个上下文中定义的所有变量和函数都存在于这个对象上。  
  全局上下文就是我们常说的 window 对象。  
  上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。  
  每个函数调用都有自己的上下文。
* 作用域  
  上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。  
  代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。

  这块似懂非懂。

* 变量声明

  - var
  - let  
    作用域是块级的。块级作用域由最近的一对包含花括号{}界定。在同一作用域内不能声明两次。

  * const  
     使用 const 声明的变量必须同时初始化为某个值。  
     const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。  
     如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：

    ```js
    const o3 = Object.freeze({})
    o3.name = 'Jake'
    console.log(o3.name) // undefined
    ```

  * 暂时性死区  
    在代码块内，使用 let/const 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
  * 标识符查找  
    当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。  
    在局部变量 color 声明之后的任何代码都无法访问全局变量 color，除非使用完全限定的写法 window.color。

#### 垃圾回收

基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的。

- 标记清理
  垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。  
  ps: 先标记在内存中的所有变量，将在上下文中的变量和上下文引用的额变量的标记去掉，之后内存清理时，会将带有标记的变量给清除。

* 引用计数  
  不常用

* 性能  
  垃圾回收有可能会明显拖慢渲染的速度和帧速率。写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。
* 内存管理  
  解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。
  - 通过 const 和 let 声明提升性能  
    使用 let const 这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。
  * 隐藏类和删除操作
    能够共享相同隐藏类的对象性能会更好。  
    动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。
  - 内存泄漏  
    未声明的对象会被当作 window 的属性来创建，在 window 对象上创建的属性，只要 window 本身不被清理就不会消失。  
    闭包很容易在不知不觉间造成内存泄漏。
  * 静态分配与对象池  
    如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。
